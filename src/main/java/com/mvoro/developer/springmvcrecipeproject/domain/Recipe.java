package com.mvoro.developer.springmvcrecipeproject.domain;

import java.util.HashSet;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.Lob;
import javax.persistence.ManyToMany;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;

import lombok.Getter;
import lombok.Setter;

/**
 * Entity classes have different requirements than plain Java classes.
 * That makes Lombokâ€™s generated equals() and hashCode() methods unusable.
 * You can use the @Getter, @Setter, and @Builder annotation without breaking your application.
 * The only Lombok annotations you need to avoid are @Data, @ToString, and @EqualsAndHashCode.
 */
@Getter
@Setter
@Entity
public class Recipe {

    // The primary key that will be autogenerated
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Cascade: We remove a Note if we remove the associated Recipe
    @OneToOne(cascade = CascadeType.ALL)
    private Note note;

    // One Recipe with many Ingredients. Mapped by "recipe" property under Ingredient object.
    // Cascade: We remove an Ingredient if we remove the Recipe
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "recipe")
    private Set<Ingredient> ingredients = new HashSet<>();

    // Initializing the Set to avoid NPEs
    @ManyToMany
    @JoinTable(name = "recipe_category",
        joinColumns = @JoinColumn(name = "recipe_id"),
        inverseJoinColumns = @JoinColumn(name = "category_id"))
    private Set<Category> categories = new HashSet<>();

    private String description;

    // A best practice and a recommendation by the Hibernate team is to use wrapper classes instead of primitives
    // as classes can be null
    private Integer prepTime;

    private Integer cookTime;

    private Integer servings;

    private String source;

    private String url;

    private String directions;

    // We choose EnumType.STRING and not EnumType.ORDINAL (the default) because we want to
    // store the enum values as Strings in the database
    @Enumerated(value = EnumType.STRING)
    private Difficulty difficulty;

    @Lob
    private Byte[] image;

    public void setNote(Note note) {
        this.note = note;
        note.setRecipe(this);
    }

    // Bidirectional relationship
    public void addIngredient(Ingredient ingredient) {
        ingredients.add(ingredient);
        ingredient.setRecipe(this);
    }

}
